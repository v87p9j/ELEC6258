java c
ELEC6258 Simulation of Mobile Communications
Matlab courseworkThis coursework forms your assessment for the Matlab part of ELEC6258 Simulation of Mobile Commu- nications.  This coursework contributes 40% of your mark for ELEC6258 and completing it should require up to 47 hours of work outside the scheduled lectures and labs.  Please do not spend any more time than this because I’m sure you have better things to be doing!  However, you should make sure that you get started on this coursework early enough to ﬁnish it before the deadline. There’s no way that you can complete a 47-hour coursework in only the week before the deadline.
In the exercises detailed below, you are asked to write some Matlab code and produce some results.  Al- though you may verbally discuss your ideas with your classmates, you should not show them your Matlab code or results. When you are ﬁnished, you should copy and paste your Matlab code and results into a Word document,which you should then save as a .pdf ﬁle. This Word document should onlyinclude the Matlab code and results that are directly requested in the bold paragraphs below - it should not include anything else.  In particular, there is no need to write a report for this coursework.
When you are ﬁnished, you need to submit the .pdf version of your Word document, your Matlab code and your result ﬁles to the electronic handin system before the deadline shown there.
As shown in the marking scheme of Table 1, one third of your marks in this coursework depend on each of the functionality, efficiency and human-readability of your Matlab code.  I will mark the human-readability of your Matlab code by looking at your Word document. I will also look at the results in your Word document to assess some aspects of your Matlab code’s functionality and efficiency.  However, I will also run your Matlab code on my computer to assess its functionality and efficiency more thoroughly.  I will do this using Matlab scripts that are similar to the ones you can download from the ELEC6258 resources webpage. Note however that my versions of these scripts include some additional tests, so you need to ensure that your Matlab code works in the general case, not just for the speciﬁc tests that are included in the scripts on the ELEC6258 resources webpage.  Some of the tests in these scripts produce measurements, which I will use to mark the functionality and efficiency of your Matlab code.  Some of the tests produce pass or fail messages and I will give higher marks for your Matlab code’s functionality if it can pass more of these tests.  Note that some of these tests deliberately give erroneous inputs to your Matlab code.  In order to pass these tests, your Matlab
code will need to generate an error message using a command like the following one. error( 'Soton:argChk ' , 'Your  error message  goes  here ');I will return your marks and the results of running your Matlab code on my computer to you within four weeks of the submission deadline. You can see how to interpret your marks in Table 2.  I will also give some general feedback and show you my solutions to the exercises in the ELEC6258 lecture that we have at the end of the semester.
If you notice any mistakes in this document or have any queries about it, please email me. Have fun! Rob Maunder
Table 1: Marking scheme33.33%Functionality. Does the Matlab code work? Does it meet thespecifications provided in the exercises below? Are the resultscorrect? Does the Matlab code generate appropriate error messages?33.33%Efficiency. How quickly does the Matlab code run? Has the Matlab code made good use of built in functions, vectors and matrices? Or does it use proprietary code and an excessive number offor loops?33.33%Human-readability. Is the Matlab code reusable, elegant and wellstructured? Does it follow good programming practice3? Doesit include useful, concise and relevant comments, which help explain its non-trivial features? Are the chosen variable names descriptive, concise and relevant? Or does the Matlab code use anexcessive number of lines? Does the Matlab code use switch,break, continue or return without having a really really goodreason to?

Table 2: How to interpret your marks40 out of 40Perfect solutions. This mark is only given if I can’t think ofany ways to improve the functionality, efficiency or humanreadability of the Matlab code and results.29–39 out of 40Excellent solutions. These marks are awarded to students thathave really thought about their solutions and have come up withclever ways to optimise the functionality, efficiency and humanreadability of the Matlab code and results.28 out of 40Solid solutions. All of the results are correct and the Matlab codeis reasonably functional, efficient and human-readable, but all thetricks for making them particularly so have been missed.20–27 out of 40Flawed solutions. Typically, these marks are given if all parts ofall exercises have been completed, but there are mistakes in theresults or Matlab code. For example, the Matlab code may workfor the specific tests provided in the scripts on the ELEC6258resources webpage, but it may not always work in the generalcase.1–19 out of 40Missing solutions. Typically, marks this low are only given ifsome of the results or Matlab code are missing from the submission. To avoid this you should make sure you budget 47 hours forcompleting this coursework outside of the scheduled lectures andlabs.0 out of 40No solutions. You would probably have to submit nothing at allto get a mark this low!
Exercise 1 - Two-dimensional parity check encoderConsider a wireless communication scheme which is designed to convey messages between a transmitter and a receiver over a wireless channel. Suppose that each message is a row vector x comprising k number of symbols. Each symbol has an integer value in the range 0 to (M 一 1), where M is known as the radix of the symbols. For example, the message vector x = [2; 0; 1; 1; 3; 2] comprises k = 6 symbols, having a radix of M = 4.A Two-Dimensional Parity Check (TDPC) encoder may be used in the transmitter to protect the message vector x from the corruption that may be imposed by the wireless channel, owing to noise, fading and interfer- ence, for example. A TDPC encoder is controlled using three parameters, namely the radix M, the number of rows i in the TDPC matrix and the number of columns j in the TDPC matrix. The TDPC encoder can be used to encode a message vector x comprising k symbols, provided that the radix M of the TDPC encoder and of the message are equal, and provided that the number of rows i and columns j are set such that (i 一 1) · (j 一 1) = k.  	The ﬁrst step in TDPC encoding is to reshape the vector x, so that it becomes a matrix X, having (i 一 1) rows and (j 一 1) columns. Taking each of the symbols in x from left to right in turn, the matrix X is populated one column at a time, starting by ﬁlling the left-most column from top to bottom, before similarly ﬁlling each of the other columns from left to right in turn.  In the case where the example message vector x = [2; 0; 1; 1; 3; 2] is
TDPC encoded using the parameters i = 3 and j = 4, we obtain the matrix X = [0(2);; 1(1);; 2(3)丨, which has (i 一 1) = 2
rows and (j 一 1) = 3 columns.In a second step, the TDPC matrix Y is formed by copying the matrix X, but adding an extra row at the bottom and an extra column at the right. Therefore, the TDPC matrix Y has i rows and j columns. The values in the extra row are set such that each column has a sum that is a multiple of M. Likewise, the values in the extra column are set such that each row has a sum that is a multiple of M.  In the case where the example message vector x = [2; 0; 1; 1; 3; 2] is TDPC encoded using the parameters i = 3 and j = 4, we obtain the TDPC matrix
「I2; 1; 3; 21'
Y = I 0; 1; 2; 1 ''', which has i = 3 rows and j = 4 columns. Note that the ﬁrst, second and fourth columns of thisexample Y have sums of 4, while the third column has a sum of 8.  Likewise, the second row has a sum of 4, while the ﬁrst and third rows have sums of 8. Note that these values of 4 and 8 are both multiples of M = 4. In other words, a remainder of zero results when dividing the sum of each row and column by M = 4, which is to say that the modulo-M = 4 sum of each row and each column is zero.In a ﬁnal step, the TDPC matrix Y is reshaped, so that it becomes a row vector y, having a length of (i · j). Taking each of the columns in Y from left to right in turn and reading the columns from top to bottom, the row vector y is populated one symbol at a time, from left to right.  In the case where the example message vector x  =  [2; 0; 1; 1; 3; 2] is TDPC encoded using the parameters i  = 3 and j  = 4, we obtain the encoded vector y = [2; 0; 2; 1; 1; 2; 3; 2; 3; 2; 1; 1], which comprises n = i · j = 12 symbols.
In this exercise, your task is to write a Matlab function which performs TDPC encoding.  Your Matlab function is required to use the following line, in order to declare the function’s name, inputs and outputs.
function  encoded_vector  =  TDPC_encoder(message_vector,  radix,  rows,  columns)Here, message_vector should accept the row vector x, while radix, rows and columns should accept the scalars M, i and j, respectively.  Your TDPC_encoder function should check that the values of these inputs are self-consistent and if not, it should generate an error message using the command provided on page 1. Otherwise, encoded_vector should return the row vector y.  You can test the functionality and efficiency of your TDPC_encoder function using the script. test_TDPC_encoder, which you can download from the ELEC6258 resources webpage. I will use a script. similar to this one to mark the functionality and efficiency of your TDPC_encoder function. Note that the mark that you receive for efficiency in this exercise will be capped by the mark that you receive for functionality.  This is because it is easy to write a Matlab function that runs quickly, but does not have all of the required functionality.
When you are ﬁnished, include a listing of your TDPC_encoder function in your Word document and submit this function to the electronic handin system.
Exercise 2 - Two-dimensional parity check decoderIn the wireless communication scheme mentioned in Exercise 1, the encoded vector y is conveyed between the transmitter and the receiver over a wireless channel. This channel may sufer from noise, interference and fading, causing the encoded vector to become corrupted.  Owing to this, some of the symbols in the received
vector y(ˆ) may have diferent values to the corresponding symbols in the encoded vector y.  Note however thatthese erroneous symbols should still have integer values in the range 0 to (M 一 1).  For example, the wireless channel could corrupt the encoded vector y  =  [2, 0, 2, 1, 1, 2, 3, 2, 3, 2, 1, 1], resulting in the received vector
y(ˆ) = [2, 1, 2, 1, 1, 2, 1, 2, 3, 2, 1, 1], which contains two erroneous symbols.A TDPC decoder may be employed in the receiver to mitigate the erroneous symbols in the vector y(ˆ) .  A TDPC decoder is controlled using three parameters, namely the radix M, the number of rows i in the TDPC matrix and the number of columns j in the TDPC matrix. The TDPC encoder can be used to decode a received vector y(ˆ), provided that it derives from an encoded vector y that has been generated using a TDPC encoder having the same parameter values.The ﬁrst step in TDPC decoding is to reshape the received vector y(ˆ) of n symbols, so that it becomes the
TDPC matrix Y(ˆ), having i rows and j columns, where i · j = n. Taking each of the symbols in y(ˆ) from left to right
in turn, the TDPC matrix Y(ˆ) is populated one column at代 写ELEC6258 Simulation of Mobile Communications Matlab courseworkMatlab
代做程序编程语言 a time, starting by ﬁlling the left-most column from
top to bottom, before similarly ﬁlling each of the other columns from left to right in turn.  In the case where
the example received vectory(ˆ) = [2, 1, 2, 1, 1, 2, 1, 2, 3, 2, 1, 1] is TDPC decoded using the parameters i = 3 and「I2,
1, 1,
21
j = 4, we obtain the TDPC matrix Y(ˆ) = I 1,
I
1, 2,1 I, which has i = 3 rows and j = 4 columns.
Il2,
2, 3,
1」In a second step, the modulo-M sum of each row and each column is calculated and analysed to identify and mitigate erroneous symbols. In the case of the example received vector y(ˆ) = [2, 1, 2, 1, 1, 2, 1, 2, 3, 2, 1, 1],「21
the modulo-M = 4 sums of the columns in Y(ˆ) are [1, 0, 2, 0], while the modulo-M = 4 sums of its rows are I 1 I .
「2  1  3  21
TDPC matrix is Y(ˆ) = I 0,, 1,, 2,, 1 I .In a fourth step, the bottom row and the right-most column of the TDPC matrix Y(ˆ) are removed, to obtain
the matrix X(ˆ) . In the case of the example received vector y(ˆ) = [2, 1, 2, 1, 1, 2, 1, 2, 3, 2, 1, 1], removing this row
and this column from the TDPC matrix Y(ˆ) results in the matrix X(ˆ) = [0(2),,1(1),, 2(3)丨, which has (i 一 1) = 2 rows and
(j 一 1) = 3 columns.In a ﬁnal step, the matrixX(ˆ) is reshaped, so that it becomes a row vector , having a length of k = (i一1)·(j一1).
Taking each of the columns inX(ˆ) from left to right in turn and reading the columns from top to bottom, the row
vector  is populated one symbol at a time, from left to right.  In the case where the example received vector
y(ˆ) = [2, 1, 2, 1, 1, 2, 1, 2, 3, 2, 1, 1] is TDPC decoded using the parameters i = 3 and j = 4, we obtain the decoded
vector  = [2, 0, 1, 1, 3, 2], which comprises k  = (i 一 1) · (j 一 1)  = 6 symbols.  Note this decoded vector  is
identical to the message vector x from Exercise 1, indicating that all erroneous symbols in the vector y(ˆ) have
been successfully mitigated.
Note that in the example above, the symbol errors have occurred in diferent rows and columns of the TDPC
matrix Y(ˆ) . Also, the rows and columns have the same set of modulo-M sums, with no repetitions within this set.This has made it easy to mitigate all of the symbol errors. However, on other occasions it can be more difficult or impossible to mitigate all of the symbol errors.  For example, some symbol errors may occur in the same row or column. Sometimes, these symbol errors can cancel each other out, causing the row or column to have a modulo-M sum of zero.  Other times, these symbol errors can cause the rows and columns to have diferent sets of modulo-M sums. Furthermore, some rows or some columns may have the same modulo-M sums.In this exercise, your task is to write a Matlab function which performs TDPC decoding and mitigates as many symbol errors as you can. Your Matlab function is required to use the following line, in order to declare the function’s name, inputs and outputs.
function  decoded_vector  =  TDPC_decoder(received_vector,  radix,  rows,  columns)
Here, received_vector should accept the row vectory(ˆ), while radix, rows and columns should accept thescalars M, i and j, respectively.  Your TDPC_decoder function should check that the values of these inputs are self-consistent and if not, it should generate an error message using the command provided on page 1. Otherwise, decoded_vector should return the row vector  .  You can test the functionality and efficiency of your TDPC_decoder function using the script. test_TDPC_decoder, which you can download from the ELEC6258 resources webpage.  Here, tests  1 to 7 can be used to evaluate the functionality of your TDPC_- decoder function.  Tests 8 to 17 can be used to evaluate whether your TDPC_decoder function can mitigate particular combinations of symbol errors. It is possible to write a TDPC_decoder function that can mitigate all of the symbol errors in tests 8 to 17, although some require much more complicated programming than others. I would advise you to ﬁnish Exercises 3 and most of Exercise 4, before attempting to pass all of tests 8 to 17. Finally, tests 18 to 20 can be used to evaluate the overall error mitigation and efficiency of your TDPC_decoder function.  I will use a script. similar to the one you can download from the ELEC6258 resources webpage to mark the functionality and efficiency of your TDPC_decoder function.  I will consider all of the tests when marking the functionality of your TDPC_decoder function, but I will pay particular attention to the results of tests 18 to 20. Note that the mark that you receive for efficiency in this exercise will be capped by the mark that you receive for functionality.  This is because it is easy to write a Matlab function that runs quickly, but does not have all of the required functionality.
When you are ﬁnished, include a listing of your TDPC_decoder function in your Word document and submit this function to the electronic handin system.
Exercise 3 - M-ary symmetric channelIn the wireless communication scheme mentioned in Exercises 1 and 2, an encoded vector y of n symbols having values in the range 0 to (M 一 1) is conveyed over a wireless channel. The resulting received vector y(ˆ) also comprises n symbols having integer values in the range 0 to (M 一 1), although some of these may have diferent values to the corresponding symbols in the encoded vector y. The occurrence of these symbol errors may be (crudely) modelled using an M-ary symmetric channel.An M-ary symmetric channel is parametrised by two parameters, namely the symbol error probability Pe in the range 0 to 1 and the radix M, which is required to equal the radix M of the encoded vector y.  The transmission of each of then symbols in the encoded vector y is modelled separately and independently, by generating a random number. Depending on the value of the random number, the value of symbol will be either
copied to the corresponding symbol in the received vector y(ˆ) without error, or will be replaced with a diferentvalue in the range 0 to (M 一 1).  This is performed such that a symbol error is avoided with a probability of (1 一 Pe) and incurred with a probability of Pe.  When a symbol error occurs, the value for the symbol in the
received vector y(ˆ) is selected from among the (M 一 1) possible incorrect values, each with the same probabilityof 1/(M 一 1). Therefore, the overall probability of receiving a particular one of these incorrect values is given by Pe  · 1/(M 一 1).For example, consider the transmission of an M = 4-ary symbol value of 2 over an M = 4-ary symmetric channel having a symbol error probability of Pe   = 0.3.  With a probability of (1 一 Pe)  = 0.7, the symbol will be correctly received with a value of 2.  However, with a probability of Pe   = 0.3, the symbol will be received incorrectly, with a value of either 0, 1 or 3. In this event, each of these incorrect values is associated with an equal probability of 1/(M 一 1) = 0.333. Therefore, the overall probability of receiving the incorrect value of 0 is given by Pe · 1/(M 一 1) = 0.1. Likewise, the probabilities of receiving the incorrect values of 1 and 3 are also both equal to 0.1. Note that the probabilities of receiving the four possible symbol values in the set {0; 1; 2; 3} are given by the set {0.1; 0.1; 0.7; 0. 1}, which sum to 1.0, as may be expected.In this exercise, your task is to write a Matlab function which simulates transmission over an M-ary sym- metric channel.  Your Matlab function is required to use the following line, in order to declare the function’s name, inputs and outputs.
function  received_vector  =  MSC(encoded_vector,  radix,  Pe)Here, encoded_vector should accept the row vector y, while radix and Pe should accept the scalars M and Pe, respectively. Your MSC function should check that the values of these inputs are self-consistent and if not, it should generate an error message using the command provided on page 1.  Otherwise, received_vector
should return the row vector y(ˆ) .  You can test the functionality and efficiency of your MSC function using thescript. test_MSC, which you can download from the ELEC6258 resources webpage. I will use a script. similar to this one to mark the functionality and efficiency of your MSC function.  Note that the mark that you receive for efficiency in this exercise will be capped by the mark that you receive for functionality. This is because it is easy to write a Matlab function that runs quickly, but does not have all of the required functionality.
When you are ﬁnished, include a listing of your MSC function in your Word document and submit this function to the electronic handin system.
Exercise 4 - Monte-Carlo simulationThe error mitigation ability of the wireless communication scheme mentioned in Exercises 1, 2 and 3 may be characterised using a Monte-Carlo simulation.  Here, we can simulate the TDPC encoding of lots of message vectors x, as well as their transmission over an M-ary symmetric channel having a particular symbol error probability Pe, while counting the total number of symbol errors in the decoded vectors  produced by the TDPC decoder. The Symbol Error Ratio (SER) is given by the total number of symbol errors in the decoded vectors  divided by the total number of symbols in the message vectors x.  We can repeat this experiment for a range of diferent values for the symbol error probability Pe  and plot the resultant SERs against Pe  on logarithmic axes, as exempliﬁed in Figure 1.  If a sufficiently high number of message vectors x have been used during the simulation for each value of the symbol error probability Pe, then a nice smooth SER plot will result.  Note that the plots of Figure 1 were obtained by using 16 processors on one node of the Lyceum supercomputer5 for 24 hours. Each data point was obtained by continuing to generate new message vectors x, until 10000 symbol errors had been observed in the corresponding decoded vectors  .In this exercise, your task is to write a Matlab script. or function that performs a Monte-Carlo simulation of the wireless communication scheme mentioned in Exercises 1, 2 and 3.  This script. or function should use an ASCII text ﬁle to save the total number of symbol errors observed in the decoded vectors , as well as the total number of symbols in the message vectors x, for each value of the symbol error probability Pe considered. Your Matlab script. or function should also plot the SER against the symbol error probability Pe  on logarithmic axes, as exempliﬁed in Figure 1. Alternatively, you may prefer to use a second Matlab script. or function to perform. the plotting.  In this exercise, you may ﬁnd it helpful to use a number of Matlab’s built in functions, such as save, load, figure, subplot, title, xlabel, ylabel, xlim, ylim, box, hold, loglog and legend.I will mark the functionality of your Matlab code by assessing the quality of your SER plot(s).  More speciﬁcally, I will be hoping to see nice smooth SER curves that are well annotated, that consider a good selection of parameter values and that include results for a good selection of symbol error probability Pe values. I will mark the efficiency of your Matab code by looking at your ASCII text ﬁle. In particular, I will be hoping to see that each SER value has been calculated using an appropriate number of symbol errors in the decoded vectors , as well as an appropriate number of symbols in the message vectors x.When you are ﬁnished, include a listing of your Matlab scripts and/or functions in your Word docu- ment, together with your SER plot(s) and one example of your ASCII text ﬁles. Also, submit these items to the electronic handin system.










         
加QQ：99515681  WX：codinghelp  Email: 99515681@qq.com
